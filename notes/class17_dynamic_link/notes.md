mmap系统调用可以修改当前进程的地址空间，把别的elf文件放入内存，当作一个加载器，实现execve的功能

动态编译loader-static.c然后，该程序可以加载那些静态链接的程序

bootmain.c是lab0中负责加载qemu镜像的代码，本质上也是一个加载器，只不过加载的是"内核代码"，512字节，以55aa结尾
但是这里不能用mmap，因为mmap是内核提供的api，代码里面用的是一个copy_from_disk函数

# 动态链接
减少磁盘空间占用
老师上课没有照着当前的elf标准讲解动态链接
而是自己提出了一个动态链接的标准
对一个动态链接可执行文件，提出了以下语法
1. load用于加载别的动态链接库
2. import用于加载外部符号
3. export把当前文件的函数导出为符号，可供其他文件引用
4. call DSYM(fun)表示这里引用的是外部链接

把dlbox编译，然后用该程序可以编译生成jyy自定义的文件格式

但有一个问题，编译的时候，会有两种情况
一种是把两个.o文件一起静态链接生成.out
另一种是一个单独的文件生成.so动态链接库

如果前面两个文件之间有链接，他是一个静态链接
但编译的时候，没法知道call到底是静态还是动态的
所以新弄一个概念叫plt，在plt里面再去考虑是静态还是动态
主函数只call symble@plt