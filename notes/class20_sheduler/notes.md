jyy没有按照书本上的顺序介绍
书本上的流程是
先假设进程
1. 时间相同
2. 同时到达
3. 没有I/O
4. 耗时已知
然后就提出了FIFO(first in first out)

接着打破假设1，即任务时间不同
于是提出了SJF(shortest job first)

然后又打破假设2，即任务到底时间不定
于是又提出STCF(shortest time-to-complete first), 即调度算法可以抢占

然后从另一个响应时间的角度，并且打破假设3，提出了RR(round-robin)


但是最大的问题就在于进程运行时间不可知
所以需要算法能够自适应的动态调节

于是又提出了多级反馈队列(MLFQ)算法
1.优先级高的进程总是先运行
2.优先级相同的进程采用RR算法
3.进程在该优先级的时间片用完后降低优先级
4.定期优先级重置

然后就还有一种彩票算法和步长算法
就是给进程分配一个优先级，然后根据优先级决定获得CPU的概率

Linux采用的CFS算法
把CPU设定一个时间单位(例如48ms)，所有进程在这个单位内均分(若4个进程，则每个进程12ms，2进程则24ms)
每个进程有一个vruntime，记录该进程运行的时长
每个进程还有一个优先级叫nice，nice越低，则权重越高(越坏的人越容易得到好处)
权重高的人时间会走得慢一点

然后就是睡眠后被唤醒的进程以及新进来的进程都会被赋予当前最小的vruntime
不能为0，否则会独占CPU

所有进程的vruntime用红黑树存储，可以快速找到vruntime最小的，插入删除也很方便

---

书上就介绍了这么多
jyy引入了新问题
如果有并发怎么办
```
void xiao_zhang() { // 高优先级
  sleep(1); // 休息一下先
  mutex_lock(&wc);
  ...
}

void xi_zhu_ren() { // 中优先级
  while (1) ;
}

void jyy() { // 最低优先级
  mutex_lock(&wc);
  ...
}
```

假设jyy先获得了锁
但因为优先级最低，之后都未能获得时间片
而校长优先级高却不能运行(锁被占用)
导致系主任一直在占用

即优先级反转了

优先级继承机制，持有mutex的线程/进程会继承block在该mutex上进程的最高优先级