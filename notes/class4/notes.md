验证并发程序的正确性就是画状态机遍历所有状态

给了一个model-checker.py来遍历程序的所有状态

用到了python的yield机制，即调用函数时，如果用yield返回，可以保留这个函数的执行状态，下次进入该函数会从退出时的状态开始执行
执行到yield时又返回一次

现在想给sum.c加上锁
问：如何设计一个代码实现锁的结构？（仅使用memory load和store操作）
```
int locked = UNLOCK;
void critical_section(){
retry:
  if (locked != UNLOCK){
    goto retry;
  }
  locked = LOCK;

  // critical section
  
  locked = UNLOCK;
}
```
上面的代码就和山寨alipay出现一样的错误，有可能两个线程同时看到没上锁，然后进入临界区
处理器不保证load+store的原子性，即先判断锁能不能用，再上锁，在C语言状态机中分成了两步
如果把判断与上锁合成为1步，锁就能正确实现

### peterson算法
前提：
store()表示修改内存状态
load()表示"看"内存中的标志,但是看到的永远是过去的状态，你不知道后来有没有人修改了你之前看的标志状态

厕所例子
进厕所前，先举旗子，然后往门上贴一个"对方名字"的标签
如果看到对方旗子已经举起，且门上是"对方名字"，就进不去

我的例子
先申请，再假让，再看对方要不要

出现竞争时：手快有，手慢无

~~但有一个问题，就是进去前需要看对方的旗子和门上的标签，这应该还是两个动作？~~

peterson-simple.c并不能保证互斥
原因应该是出在x86内存模型上
写操作不一定能马上被别的线程看见，导致对方线程更新了状态，但你在while循环的时候读的不是最新值
而不是上面的while不能同时判断两个条件的原因

## dekker算法
先举旗子，再看对方的旗子
如果看到对方举，且标志为对方优先
**就会放下旗子**
然后死循环等待，直到ture变成自己
再重新举旗