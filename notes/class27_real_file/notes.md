文件系统和内存有差别
内存模型中，存取粒度为字，即一次访问最多读取8字节
但是文件是按块存取的，一次读取4KB
即使只读取1个字节，也要从磁盘里读取一整块
从程序员的角度来说，如果把磁盘当作内存看待，让文件访问由大量的字(或字节)操作构成，是十分浪费性能的

总而言之，设计文件系统时，必须考虑磁盘是按照块进行读写的模型
设计文件系统本质就是设计数据结构，用来组织磁盘中的数据
目录也是一种文件

需要实现的4种api
block alloc(块分配),block free(块回收),block read(块读取),block write

## balloc设计
### 可能的方法？
- 每个块尾部保存一个指针指向下一个块，做成链表的形式
- 留出一些块来用于保存bitmap
总之发挥空间挺大的,书中给出的答案是有一个专门的元数据块inode，里面有指针指向文件的数据块
遇到大文件会采用多级指针的形式，即第一个指针指向某一个数据块，这个数据块里面存放的全都是指针，指向别的数据块。

## block array(属于同一个文件的逻辑连续的块)设计

## 目录内容设计
所谓目录内容设计，其实就是struct的设计，负责记录各个文件的相关信息(文件名，属性，数据块的位置等)

目录底下会存放该路径有哪些文件或子目录(存放的内容本质就是一个struct数组)

如果底下有子目录，它也会被当作一种文件看待
    例如/home目录下面有一个子目录/home/lee/
    那么这个lee也会和其他文件一样，用一个struct记录他的相关信息


所以其实目录和文件没有本质区别，只不过是他们里面存放的数据不同






## File Allocation Table(FAT)
磁盘容量小，才几百K
文件也比较小
文件的最小单位是簇，一簇由多个sector组成

到底是FAT12,FAT16,还是FAT32
**只与磁盘中簇的个数有关**

1. balloc/bfree
用空闲链表即可

2. block array
- 用链表的方式，把属于同一文件的块链接起来
缺点就是如果执行lseek对文件进行random access，还是需要从头开始读取整个文件，文件里的每一个块都需要读

- 把所有的指针集中存放在某个区域(这里与书上的inode不太一样,fat32是把磁盘多个扇区打包成簇，然后fat区域记录整个磁盘的簇信息，例如fat[7]=10，就表示第7簇的下一簇是第十簇)
缺点就是一旦该区域损坏，所有数据丢失

两者上述缺点，后者可以通过备份弥补，但前者缺点很严重
所以选了第二个方案

3. 目录和文件名的结构
详见手册section6
DIR_Attr用于区分这个struct代表的是目录还是文件


查看fat文件系统
yes | head -c 104857600 > fs.img 生成一个虚拟镜像文件
然后把这个img挂载成一个目录/mnt/d
往里面写创建文件和目录
然后用fatree.c就可以查看这整个目录了

### 注意:FAT32标准要求短文件名必须**大写**
当采用小写文件名时，FAT32会把该文件认作一个长名文件，用两个文件项来存储
长名文件的文件项的Attr值为0x0f,用于存放真正的文件名
而真正的文件项会把名字转换成大写存储
Short file names passed to the file system are always converted to upper case and their original case value is lost.

## ext2
相比FAT32，在磁盘里单独开辟空间存放metadata，就是书中的inode
inode里面负责存放指针
大部分指针直接指向数据块(针对小文件)
**这里与FAT32不同的点在于，属于该文件每一个块都有一个单独的指针负责索引，而FAT32则是链表形式**

还有指针可以指向一个存放二级指针的块(针对大文件)


对于目录项或者文件项，只需要记录inode编号和一些简单的参数即可

