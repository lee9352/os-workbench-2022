execve系统调用的第一个参数就是可执行文件
而execve调用是重置进程状态机
所以可执行文件就是一个描述进程状态机的**初始状态（寄存器+内存）**的数据结构
例如rip寄存器(就是pc寄存器)，需要由elf给出 

可执行文件还会包含一些信息，gdb调试时可用(编译时添加-g选项)
例如gdb可以知道该指令处于源码中的第几行

但是调试信息不一定都正确(调试信息本质就是把机器视角状态机映射回c程序视角)
原因在于，编译器把c程序视角的状态机翻译成机器视角的状态机
但有时编译器会对代码进行优化，比如删除掉一些用不到的变量相关的指令和寄存器分配

于是debug info就不知道该从哪个寄存器寻找该变量的值
popcount.c在用gdb调试时，不能正确打印函数内各个变量的值

unwind.c展示了gdb中bt
调试器是如何找到函数嵌套调用的
利用的是每次函数调用时，都会存放ret addr，然后进入新函数时，将rbp的值压入栈，然后更新rbp

每个函数栈的rbp位置就形成了一个**链表**，rbp相邻的位置存的就是返回地址

对unwind.c进行O2优化会丢失一些调用信息，但是gdb的bt仍能找到完整的调用
说明编译器还添加了一些其他信息

# 链接
编译时，当调用的函数不在文件内定义时，就不知道call哪个地址，就先不填，用一个标志记录即可
查看objdump -d main.o，发现call指令的地址为全0

具体来说，就是汇编会添加一些约束条件，形成.o目标文件

链接时，会处理所有目标文件，然后进行重定位工作，计算并填入跳转地址

通过readelf -a main.o查看elf文件信息
重定向填入的数据offset(目标地址与下一条指令的差值) = S+A-P
P是需要填入的地址
S是目标地址
A=-4