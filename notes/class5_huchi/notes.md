## 锁的难点
实现锁的困难点：不能同时进行内存的读和写操作
在现实世界中，以上厕所为例，我们锁上厕所门的时候，可以确保它是空闲的

但对于计算机而言：读和写是分开的两步操作

- 你可以先“看”（读取load内存）锁是否可用，但看的时候不能修改

- 当你去“上锁”（修改store内存）的时候，必须闭着眼睛操作（只往内存中某个位置写，而不会去看这个位置的值），即：你不知道你修改的那一刻，锁的值是什么



## 如何实现锁
### 软件方法
Peterson,Dekker算法(注意内存模型)

### 大胆打破之前的限制
之前的认知里，计算机是不能同时又读又写内存的，导致锁的实现很困难
那如果让硬件添加一个同时完成读+写(load+store，确保load与store是连续不被中断的)的指令，锁的实现不就容易得多了？

各个指令系统里面都提供了这种机制，由专门的原子指令来使用这个机制

## 原子指令
原子指令有一个barrier特性
在它之前的指令都已经写入内存
### atomic exchange
原子的交换内存中的两个变量~~，感觉这条指令并不是 读+写 的机制~~
~~而是可以原子的交换内存中的变量~~
相当于同时把内存中锁的值读到了本地的局部变量，又修改了内存中的锁的值

基于exchange的自旋锁

```
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES)
}
```

### 原子指令的实现
#### 80486
当时的缓存是在主板上的
只需要在硬件总线上有一个锁即可
所以原子指令带lock前缀


#### 现代情况
现在每个cpu都有独占的缓存，要考虑缓存一致性
可能两个cpu都有同一地址的副本
需要在L1缓存之间有通信
给某一块地址上锁时，要把其他cpu内的副本踢出去

#### RISC-V
LR/SC指令对
原子指令本质上有三个步骤
- load
- exec
- store

LR会在load的时候，给内存打上标记
SC会破坏掉标记



## 自旋锁
没获得锁的线程会自旋，造成性能浪费
### 使用场景
**一些要求**
1. 临界区几乎不拥堵
2. 持有锁的线程不能被调度出去(即要禁止中断，意味着用户态几乎不能用他，否则存在被调度出去的可能性，影响性能)

所以常用于操作系统内核的并发数据结构 (短临界区)



## 互斥锁
把锁的实现放在操作系统中，
syscall(SYSCALL_lock, &lk);
  试图获得 lk，但如果失败，就切换到其他线程
syscall(SYSCALL_unlock, &lk);
  释放 lk，如果有等待锁的线程就唤醒

**操作系统使用spin lock确保自己对lk的处理是原子的**
相比于自旋锁的特点
1. 更快的slow path(获得锁失败时不用自旋)
2. 更慢的fast path(即使获得锁，也需要进入内核)

## Futex: Fast Userspace muTexes
对互斥锁进行优化
上锁仅用一条原子指令
若上锁失败，再进入内核睡眠
例:futex.py