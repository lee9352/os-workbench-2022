## 自旋锁
没获得锁的线程会自旋，造成性能浪费
### 使用场景
**一些要求**
1. 临界区几乎不拥堵
2. 持有锁的线程不能被调度出去(即要禁止中断，意味着用户态几乎不能用他，否则存在被调度出去的可能性，影响性能)

所以常用于操作系统内核的并发数据结构 (短临界区)



## 互斥锁
把锁的实现放在操作系统中，
syscall(SYSCALL_lock, &lk);
  试图获得 lk，但如果失败，就切换到其他线程
syscall(SYSCALL_unlock, &lk);
  释放 lk，如果有等待锁的线程就唤醒

**操作系统使用spin lock确保自己对lk的处理是原子的**
相比于自旋锁的特点
1. 更快的slow path(获得锁失败时不用自旋)
2. 更慢的fast path(即使获得锁，也需要进入内核)

## Futex: Fast Userspace muTexes
对互斥锁进行优化
上锁仅用一条原子指令
若上锁失败，再进入内核睡眠
例:futex.py