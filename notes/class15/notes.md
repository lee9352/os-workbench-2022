文件描述符是在打开或者创建文件时由操作系统提供的

所以就解释了在不同终端下的bash，虽然文件描述符都是012
但指向了不同的终端设备

执行fork()时，会复制父进程的文件描述符，指向同样的文件
执行execve()时，重置了进程状态机，但没有重置文件描述符

所以就解释了在同一终端下，用命令创建新进程时，新进程依然输出在该终端内

所以bash管道需要调整一下进程的文件描述符

fork-execve实现(copy-on-write)
fork复制进程，不可能真的复制了一份，不然开销太大了
就算真的复制，也会马上被execve重置

其实进程本身不占有任何一页内存，物理内存页全部归操作系统持有，进程地址都会映射到某个物理页
所以fork后的新进程也指向了同一个物理页面(引用计数+1)
如果某一个共享页需要修改
那么子进程修改的时候，才复制这一页

这种实现还有一种优点就是，许多进程都会用到libc的代码
内存里面只需要一份libc的页面就行了，各个进程都引用同一个物理页


# 平行宇宙
fork可以用来dfs，每个子进程走一个方向，走到头就退出，都不需要回溯了

可以在主进程初始化之后，用fork来运行各种可执行文件，避免重复初始化
安卓的app就是这样的，其底层是java，但只需加载一次初始化信息，就能供所有app打开时使用

并发编程的checkpoint也是用的fork机制


# abc
多线程执行fork，只复制该线程，而不会复制整个进程