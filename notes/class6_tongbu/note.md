线程同步：在某个时间点共同达到互相已知的状态

大部分并发问题都是生产者消费者问题

pc.c仅用锁实现同步
查看共享变量时用锁
然后交给pc-check.py检查

用互斥锁实现同步的缺点是，**所有线程都会不断访问锁，然后查询共享变量**
即当条件不满足时，线程会占用cpu并自旋

所以引入了条件变量机制，目的是把pc.c中的自旋操作改成睡眠
即当条件不满足时，该线程被踢出cpu，进入条件变量等待，直到条件满足而被唤醒

pc-cv.c
如果只有一组生产消费者，看上去没有问题
但如果出现多组的情况呢？
生产者与消费者会进入同一个条件变量
生产者可能会唤醒生产者，或者消费者唤醒消费者

**如果仅把if换成while，会出现死锁**

还应该用不同的条件变量加以区分，使生产者位于一个条件变量，消费者位于另一个

pc-sem.c
信号量做法
需要两个信号量，一个用于表示缓冲区还有空位(告诉生产者)，另一个表示缓冲区还有资源(告诉消费者)
初始时，把empty置为缓冲区大小，表示缓冲区有n个空位

哲学家问题
用p操作分别取左手餐具和右手餐具，会导致死锁
直接用条件变量就很好写